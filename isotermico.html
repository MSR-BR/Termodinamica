<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Simulador Processo Isotérmico</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{ --cil-alt:320px; --cil-larg:220px; --pist-alt:22px; }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:#0f172a;background:#f8fafc}
    header{padding:16px 12px 0 12px;text-align:center}
    header h1{margin:0;font-size:1.6rem}
    header p{margin:.3rem 0 0 0;color:#334155}

    .app{display:grid;grid-template-columns:360px 320px 1fr;gap:14px;padding:14px}
    @media (max-width:1100px){.app{grid-template-columns:1fr}}

    .card{background:#fff;border:1px solid #e2e8f0;border-radius:16px;padding:10px}
    .card h3{margin:4px 0 8px 0}

    /* Cena do cilindro */
    .scene{display:flex}
    .reservatorio{width:82px;height:var(--cil-alt);border:3px solid #334155;border-right:3px dotted #334155;background:#fff7e6;border-radius:12px 0 0 12px;margin-right:-3px;display:flex;justify-content:center;align-items:center}
    .reservatorio span{transform:rotate(-90deg);font-weight:700;color:#334155}
    .cil{position:relative;width:var(--cil-larg);height:var(--cil-alt);border-left:3px dotted #334155;border-right:3px solid #334155;border-bottom:3px solid #334155;border-radius:0 12px 12px 12px;background:#ffffff;overflow:hidden}
    .gas{position:absolute;left:0;width:100%;background:linear-gradient(#bae6fd,#e2e8f0);bottom:0}
    .pist{position:absolute;left:0;width:100%;height:var(--pist-alt);background:linear-gradient(#475569,#94a3b8);border-bottom:1px solid #0f172a22;z-index:1}
    .traj{position:absolute;left:0;right:0;border-left:2px dashed #94a3b8;opacity:.9}
    .arrow-horizontal,.arrow-vertical{position:absolute}
    .label-q,.label-w{position:absolute;font-weight:700}
    .arrow-horizontal{left:8px;bottom:10px;width:100px;height:40px}
    .label-q{left:14px;bottom:30px;color:#dc2626}
    .arrow-vertical{right:10px;width:20px;height:50px}
    .label-w{right:40px;color:#2563eb}

    .controls{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px}
    .ctrl{background:#ffffff;border:1px solid #e2e8f0;border-radius:12px;padding:8px}
    .ctrl h4{margin:0 0 6px 0}
    .row{display:flex;align-items:center;gap:8px;margin:6px 0}
    .row label{width:90px;color:#334155}
    .row input[type="range"]{width:100%}
    .row input[type="number"]{width:90px}
    button{appearance:none;background:#0ea5e9;color:#fff;border:none;border-radius:10px;padding:7px 10px;font-weight:700;cursor:pointer}
    button.secondary{background:#64748b}

    .kv{display:grid;grid-template-columns:auto 1fr;gap:6px;font-variant-numeric:tabular-nums}
    .kv div:nth-child(odd){color:#334155}
    .badge{display:inline-block;padding:2px 8px;border-radius:999px;font-size:.8rem}
    .ok{background:#d1fae5;color:#065f46}
    .warn{background:#fee2e2;color:#991b1b}

    /* Gráfico */
    .plotWrap{position:relative}
    #plot{width:100%;height:360px;border-radius:12px;background:#fff;border:1px solid #e2e8f0;display:block}
    .legend{display:flex;gap:16px;align-items:center;margin-top:6px;color:#334155}
    .legSwatch{width:14px;height:14px;border-radius:3px;border:1px solid #334155}
    .tip{position:absolute;pointer-events:none;background:#111827;color:#fff;padding:6px 8px;border-radius:8px;font-size:12px;box-shadow:0 4px 10px #0002;display:none;white-space:nowrap}
  </style>
</head>
<body>
  <header>
    <h1>Processo Isotérmico</h1>
    <p><b>Objetivo:</b> visualizar expansão/ compressão isotérmicas de um gás ideal, com pistão, cálculos de ΔQ, ΔW, ΔS e o gráfico S (J/K) × T (K) para duas pressões. Passe o mouse no gráfico para ler (S,T,P).</p>
     <p class="small">Desenvolvido por <strong>Mario Reis</strong> — Instituto de Física, Universidade Federal Fluminense (UFF) · <a href="mailto:marioreis@id.uff.br">marioreis@id.uff.br</a> · <a href="https://profmarioreis.wordpress.com" target="_blank" rel="noopener">profmarioreis.wordpress.com</a> · <span id="dateTag"></span></p>
  </header>

  <div class="app">
    <!-- Coluna 1: Cena + Controles -->
    <div class="card">
      <div class="scene">
        <div class="reservatorio"><span>reservatório térmico</span></div>
        <div class="cil" id="cil">
          <div class="traj" id="traj"></div>
          <div class="gas" id="gas"></div>
          <div class="pist" id="pistao"></div>

          <div class="arrow-horizontal" id="arrowQ">
            <svg viewBox="0 0 100 40" width="100" height="40">
              <line x1="0" y1="20" x2="100" y2="20" stroke="#dc2626" stroke-width="4" />
              <polygon id="headQ" points="90,10 90,30 100,20" fill="#dc2626" />
            </svg>
          </div>
          <div class="label-q" id="labelQ">ΔQ &lt; 0</div>

          <div class="arrow-vertical" id="arrowW">
            <svg viewBox="0 0 20 50" width="20" height="50">
              <line x1="10" y1="50" x2="10" y2="0" stroke="#2563eb" stroke-width="4" />
              <polygon id="headW" points="5,15 15,15 10,0" fill="#2563eb" />
            </svg>
          </div>
          <div class="label-w" id="labelW">ΔW &gt; 0</div>
        </div>
      </div>

      <div class="controls">
        <div class="ctrl" style="grid-column:1/3">
          <h4>Volume (trajeto do pistão)</h4>
          <div class="row">
            <label for="vol">V (L)</label>
            <input id="vol" type="range" min="0" max="100" value="60" />
            <input id="volRead" type="number" step="0.01" />
          </div>
          <div class="row" style="justify-content:space-between">
            <button id="markIni">Fixar estado inicial</button>
            <button id="markFim" class="secondary">Marcar estado final</button>
            <button id="reset" class="secondary">Reset</button>
          </div>
        </div>
        <div class="ctrl">
          <h4>Parâmetros (Gás Ideal)</h4>
          <div class="row"><label for="nMol">n (mol)</label><input id="nMol" type="number" value="0.50" step="0.01"></div>
          <div class="row"><label for="temp">T (K)</label><input id="temp" type="number" value="300" step="1"></div>
          <div class="row"><label for="t0">T₀ (K)</label><input id="t0" type="number" value="300" step="1"></div>
        </div>
        <div class="ctrl">
          <h4>Referência de Pressão</h4>
          <div class="row"><label for="p0">P₀ (kPa)</label><input id="p0" type="number" value="100" step="1"></div>
          <div class="row"><label for="pa">Pᴀ/P₀</label><input id="pa" type="number" value="0.01" step="0.01"></div>
          <div class="row"><label for="pb">Pʙ/P₀</label><input id="pb" type="number" value="0.10" step="0.01"></div>
        </div>
      </div>
    </div>

    <!-- Coluna 2: Valores e cálculos -->
    <div class="card">
      <h3>Valores (estado atual)</h3>
      <div class="kv" id="vals"></div>
      <hr>
      <h3>Cálculos do processo (isotérmico ideal)</h3>
      <div class="kv" id="process"></div>
      <p style="margin-top:8px;color:#334155;font-size:.9rem">Sinais: ΔW>0 = trabalho <b>no</b> gás (compressão); ΔW<0 = trabalho <b>pelo</b> gás (expansão). Em isotérmico ideal, ΔU=0 ⇒ ΔQ = −ΔW.</p>
    </div>

    <!-- Coluna 3: Gráfico S(T) -->
    <div class="card">
      <h3>Entropia do gás ideal: S (J/K) vs T (K) — duas pressões</h3>
      <div class="plotWrap">
        <canvas id="plot"></canvas>
        <div id="tooltip" class="tip"></div>
      </div>
      <div class="legend">
        <div class="leg"><span class="legSwatch" style="background:#f59e0b"></span> Pʙ/P₀</div>
        <div class="leg"><span class="legSwatch" style="background:#ef4444"></span> Pᴀ/P₀</div>
        <div style="margin-left:auto">marcador em T (K) atual</div>
      </div>
    </div>
  </div>

  <script>
    // ---------- Constantes e elementos ----------
    const R = 8.314462618; // J/mol/K

    const pistMinTop = 28, pistMaxTop = 220, pistAlt = 22; // px
    const Vmin = 0.20, Vmax = 2.00; // L (ampliado para permitir Vf/Vi até 10 e ΔS ≈ 9.59 J/K com n=0.5)

    function sliderToV(x){ return Vmin + (x/100)*(Vmax-Vmin); }
    function fracFromV(V){ return (V - Vmin)/(Vmax - Vmin); }
    function topFromV(V){ const f=Math.min(1,Math.max(0,fracFromV(V))); return pistMaxTop - f*(pistMaxTop - pistMinTop); }

    const pistao = document.getElementById('pistao');
    const gas = document.getElementById('gas');
    const traj = document.getElementById('traj');
    const arrowW = document.getElementById('arrowW');
    const labelW = document.getElementById('labelW');
    const arrowQ = document.getElementById('arrowQ');
    const labelQ = document.getElementById('labelQ');

    const vol = document.getElementById('vol');
    const volRead = document.getElementById('volRead');
    const nMol = document.getElementById('nMol');
    const temp = document.getElementById('temp');
    const t0 = document.getElementById('t0');
    const p0 = document.getElementById('p0');
    const pa = document.getElementById('pa');
    const pb = document.getElementById('pb');

    const vals = document.getElementById('vals');
    const process = document.getElementById('process');

    const plot = document.getElementById('plot');
    const plotWrap = document.querySelector('.plotWrap');
    const tooltip = document.getElementById('tooltip');
    const ctx = plot.getContext('2d');

    // Estado do gráfico (para hover)
    const G = {ready:false};

    let Vi=null, Vf=null; // volumes marcados
    let prevVol = sliderToV(+vol.value);
    let moveDir = -1; // -1 expansão; +1 compressão

    // ---------- Cena e setas ----------
    function updateScene(sliderVal, prevVolume){
      const V = sliderToV(sliderVal);
      const top = topFromV(V);
      pistao.style.top = top + 'px';
      gas.style.top = (top + pistAlt) + 'px';

      // faixa do volume atual até o fundo
      traj.style.top = top + 'px';
      traj.style.height = (pistMaxTop - top) + 'px';

      const expansao = V > prevVolume;
      const compressao = V < prevVolume;
      if(expansao){ // ΔQ>0; ΔW(no gás)<0
        arrowQ.style.transform='scaleX(1)'; labelQ.textContent='ΔQ > 0';
        arrowW.style.transform='scaleY(1)'; labelW.textContent='ΔW < 0';
        moveDir=-1;
      } else if(compressao){ // ΔQ<0; ΔW(no gás)>0
        arrowQ.style.transform='scaleX(-1)'; labelQ.textContent='ΔQ < 0';
        arrowW.style.transform='scaleY(-1)'; labelW.textContent='ΔW > 0';
        moveDir=+1;
      }
      volRead.value = V.toFixed(2);
    }

    function drawTrajectory(){
      if(Vi!==null){
        const topIni = topFromV(Vi);
        const topNow = topFromV(sliderToV(+vol.value));
        traj.style.display='block';
        traj.style.top = Math.min(topIni, topNow)+'px';
        traj.style.height = Math.abs(topNow-topIni)+'px';
      }
    }

    // ---------- Painéis ----------
    function calcPanels(){
      const n=+nMol.value, T=+temp.value;
      const V = sliderToV(+vol.value); const Vm3 = V/1000;
      const PkPa = (n*R*T/Vm3)/1000;
      vals.innerHTML = `
        <div>V atual</div><div><b>${V.toFixed(3)}</b> L</div>
        <div>P atual</div><div><b>${PkPa.toFixed(2)}</b> kPa</div>
        <div>n</div><div>${n.toFixed(3)} mol</div>
        <div>T</div><div>${T.toFixed(1)} K</div>`;

      let out='';
      if(Vi!==null) out += `<div>Vᵢ</div><div>${Vi.toFixed(3)} L</div>`;
      if(Vf!==null) out += `<div>V f</div><div>${Vf.toFixed(3)} L</div>`;
      if(Vi!==null && Vf!==null){
        const W_on = - n*R*T*Math.log(Vf/Vi);
        const Q = - W_on;
        const dS = n*R*Math.log(Vf/Vi);
        const Vi_m3=Vi/1000, Vf_m3=Vf/1000;
        const Pi=(n*R*T)/Vi_m3/1000, Pf=(n*R*T)/Vf_m3/1000; // kPa
        out += `
          <div>Processo</div><div><span class="badge ${Vf>Vi?'warn':'ok'}"><b>${Vf>Vi?'EXPANSÃO':'COMPRESSÃO'}</b></span></div>
          <div>Pᵢ → P f</div><div>${Pi.toFixed(2)} → ${Pf.toFixed(2)} kPa</div>
          <div>ΔW (no gás)</div><div><b>${W_on.toFixed(2)}</b> J</div>
          <div>ΔQ (ideal)</div><div><b>${Q.toFixed(2)}</b> J</div>
          <div>ΔU</div><div>0 J (isotérmico ideal)</div>
          <div>ΔS = nR ln(Vf/Vᵢ)</div><div><b>${dS.toFixed(3)}</b> J/K</div>
        `;
      }
      process.innerHTML = out || '<div>Marque estados inicial e final para calcular.</div>';
    }

    // ---------- Gráfico S(T) (J/K × K) com hover ----------
    function redrawEntropy(){
      const T0v = +t0.value; const P0v = +p0.value*1000; const rAv=+pa.value, rBv=+pb.value;
      const Tv = +temp.value; const nv = +nMol.value;

      const W = plot.clientWidth||800, H = plot.clientHeight||360; plot.width=W; plot.height=H;
      ctx.clearRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H);

      const Tmin=0.2*T0v, Tmax=4*T0v;
      const Srel=(T,P)=> nv*R*(2.5*Math.log(T/T0v) - Math.log(P/P0v));

      // range S considerando também o processo marcado
      let Smin=Infinity,Smax=-Infinity;
      for(let i=0;i<=200;i++){const t=Tmin+(i/200)*(Tmax-Tmin); const a=Srel(t,rAv*P0v), b=Srel(t,rBv*P0v); Smin=Math.min(Smin,a,b); Smax=Math.max(Smax,a,b);} 
      if(Vi!==null && Vf!==null){ const Pi=(nv*R*Tv)/(Vi/1000), Pf=(nv*R*Tv)/(Vf/1000); const Si=Srel(Tv,Pi), Sf=Srel(Tv,Pf); Smin=Math.min(Smin,Si,Sf); Smax=Math.max(Smax,Si,Sf); }
      const pad=0.12*(Smax-Smin||1); Smin-=pad; Smax+=pad;

      const x=(T)=>60+((T-Tmin)/(Tmax-Tmin))*(W-100);
      const y=(S)=>20+(1-(S-Smin)/(Smax-Smin))*(H-64);
      const invX=(xx)=> { const f=(xx-60)/(W-100); return Math.min(Tmax, Math.max(Tmin, Tmin + f*(Tmax-Tmin))); };

      // grid + eixos
      ctx.strokeStyle='#e2e8f0'; for(let i=0;i<=8;i++){const xx=x(Tmin+(i/8)*(Tmax-Tmin)); ctx.beginPath(); ctx.moveTo(xx,20); ctx.lineTo(xx,H-44); ctx.stroke();}
      for(let i=0;i<=8;i++){const yy=y(Smin+(i/8)*(Smax-Smin)); ctx.beginPath(); ctx.moveTo(60,yy); ctx.lineTo(W-40,yy); ctx.stroke();}
      ctx.strokeStyle='#334155'; ctx.beginPath(); ctx.moveTo(60,20); ctx.lineTo(60,H-44); ctx.lineTo(W-40,H-44); ctx.stroke();
      ctx.fillStyle='#334155'; ctx.font='12px system-ui'; ctx.textAlign='center'; ctx.textBaseline='top'; for(let i=0;i<=8;i++){const tt=Tmin+(i/8)*(Tmax-Tmin); ctx.fillText(Math.round(tt), x(tt), H-40);} ctx.textAlign='right'; ctx.textBaseline='middle'; for(let i=0;i<=8;i++){const ss=Smin+(i/8)*(Smax-Smin); ctx.fillText(ss.toFixed(1), 56, y(ss));}

      function curve(P,color){ctx.beginPath(); ctx.strokeStyle=color; ctx.lineWidth=2; for(let i=0;i<=200;i++){const tt=Tmin+(i/200)*(Tmax-Tmin); const S=Srel(tt,P); const xx=x(tt), yy=y(S); if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);} ctx.stroke();}
      curve(rBv*P0v,'#f59e0b'); curve(rAv*P0v,'#ef4444');

      // marcador T atual
      const xM = x(Tv); ctx.setLineDash([6,4]); ctx.strokeStyle='#111827'; ctx.beginPath(); ctx.moveTo(xM,20); ctx.lineTo(xM,H-44); ctx.stroke(); ctx.setLineDash([]);

      // pontos S_A, S_B em T atual
      const SA=Srel(Tv,rAv*P0v), SB=Srel(Tv,rBv*P0v); const yA=y(SA), yB=y(SB);
      ctx.fillStyle='#ef4444'; ctx.beginPath(); ctx.arc(xM,yA,3,0,2*Math.PI); ctx.fill(); ctx.fillStyle='#f59e0b'; ctx.beginPath(); ctx.arc(xM,yB,3,0,2*Math.PI); ctx.fill();
      ctx.fillStyle='#0f172a'; ctx.textAlign='left'; ctx.textBaseline='middle';
      ctx.fillText(`Sᴀ=${SA.toFixed(2)} J/K`, xM+8, yA-12);
      ctx.fillText(`Sʙ=${SB.toFixed(2)} J/K`, xM+8, yB+12);

      // rótulos das pressões (deslocados para não sobrepor)
      function labelPressure(r,color,dy){const Tstar=Math.min(Tmax-0.05*(Tmax-Tmin),Math.max(Tmin+0.05*(Tmax-Tmin), 1.0*T0v)); const xx=x(Tstar); const yy=y(Srel(Tstar,r*P0v))+dy; const text=`P=${(r*(+p0.value)).toFixed(2)} kPa`; ctx.font='12px system-ui'; const pad=4, tw=ctx.measureText(text).width, th=16, rx=6; const bx=xx+8, by=yy-12, bw=tw+pad*2, bh=th; ctx.fillStyle='#fff'; ctx.strokeStyle='#94a3b8'; ctx.beginPath(); ctx.moveTo(bx+rx,by); ctx.lineTo(bx+bw-rx,by); ctx.quadraticCurveTo(bx+bw,by,bx+bw,by+rx); ctx.lineTo(bx+bw,by+bh-rx); ctx.quadraticCurveTo(bx+bw,by+bh,bx+bw-rx,by+bh); ctx.lineTo(bx+rx,by+bh); ctx.quadraticCurveTo(bx,by+bh,bx,by+bh-rx); ctx.lineTo(bx,by+rx); ctx.quadraticCurveTo(bx,by,bx+rx,by); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(xx, y(Srel(Tstar,r*P0v))); ctx.lineTo(bx, by+bh/2); ctx.strokeStyle=color; ctx.stroke(); ctx.fillStyle='#0f172a'; ctx.textAlign='left'; ctx.textBaseline='top'; ctx.fillText(text, bx+pad, by+2);}
      labelPressure(rAv,'#ef4444',-14); labelPressure(rBv,'#f59e0b',+14);

      // seta do processo (se Vi/Vf dados) + ΔS numérico do gráfico
      if(Vi!==null && Vf!==null){ 
        const Pi=(nv*R*Tv)/(Vi/1000); const Pf=(nv*R*Tv)/(Vf/1000);
        const Si=Srel(Tv,Pi), Sf=Srel(Tv,Pf); const yi=y(Si), yf=y(Sf);
        const dS_graph = Sf - Si; // deveria ser nR ln(Vf/Vi)
        if(Vf>Vi){ drawArrow(xM,Math.max(yi,yf),xM,Math.min(yi,yf),'#111827'); } else if(Vf<Vi){ drawArrow(xM,Math.min(yi,yf),xM,Math.max(yi,yf),'#111827'); }
        ctx.fillStyle='#111827'; ctx.textAlign='center'; ctx.fillText(`ΔS = ${dS_graph.toFixed(3)} J/K`, xM, (yi+yf)/2 - 12);
      }

      // salvar estado para hover
      G.ready=true; G.Tmin=Tmin; G.Tmax=Tmax; G.Smin=Smin; G.Smax=Smax; G.x=x; G.y=y; G.invX=invX; G.Srel=Srel; G.rA=rAv; G.rB=rBv; G.P0=P0v; G.T0=T0v; G.n=nv; G.W=W; G.H=H;
    }

    function drawArrow(x1,y1,x2,y2,color){ const ang=Math.atan2(y2-y1,x2-x1); ctx.strokeStyle=color; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); const head=8; ctx.beginPath(); ctx.moveTo(x2,y2); ctx.lineTo(x2-head*Math.cos(ang-Math.PI/6), y2-head*Math.sin(ang-Math.PI/6)); ctx.lineTo(x2-head*Math.cos(ang+Math.PI/6), y2-head*Math.sin(ang+Math.PI/6)); ctx.closePath(); ctx.fillStyle=color; ctx.fill(); }

    // ---------- Hover: mostrar (S,T,P) ----------
    plot.addEventListener('mousemove', (ev)=>{
      if(!G.ready) return;
      const rect = plot.getBoundingClientRect();
      const px = ev.clientX - rect.left; const py = ev.clientY - rect.top;
      const T = G.invX(px);
      const SA = G.Srel(T, G.rA*G.P0); const SB = G.Srel(T, G.rB*G.P0);
      const yA = G.y(SA), yB = G.y(SB);
      const dA = Math.abs(py - yA), dB = Math.abs(py - yB);
      const isA = dA < dB; const S = isA ? SA : SB; const r = isA ? G.rA : G.rB; const color = isA ? '#ef4444' : '#f59e0b';
      const PkPa = (r * (+p0.value)).toFixed(2);

      // redesenha para mostrar cruz e ponto
      redrawEntropy();
      ctx.strokeStyle='#64748b'; ctx.setLineDash([3,3]); ctx.beginPath(); ctx.moveTo(px,20); ctx.lineTo(px,G.H-44); ctx.stroke(); ctx.setLineDash([]);
      ctx.fillStyle=color; ctx.beginPath(); ctx.arc(px, G.y(S), 4, 0, 2*Math.PI); ctx.fill();

      // tooltip
      tooltip.style.display='block';
      tooltip.innerHTML = `T=${T.toFixed(1)} K · P=${PkPa} kPa · S=${S.toFixed(2)} J/K`;
      const tx = Math.min(rect.width - tooltip.offsetWidth - 8, px + 12);
      const ty = Math.max(8, Math.min(rect.height - tooltip.offsetHeight - 8, G.y(S) - 28));
      tooltip.style.left = tx + 'px';
      tooltip.style.top = ty + 'px';
    });
    plot.addEventListener('mouseleave', ()=>{ tooltip.style.display='none'; redrawEntropy(); });

    // ---------- Eventos ----------
    function onAnyChange(){ calcPanels(); redrawEntropy(); drawTrajectory(); }
    vol.addEventListener('input', e=>{ const sv=+e.target.value; updateScene(sv, prevVol); prevVol=sliderToV(sv); onAnyChange(); });
    ;[nMol,temp,t0,p0,pa,pb].forEach(el=> el.addEventListener('input', onAnyChange));
    document.getElementById('markIni').addEventListener('click', ()=>{ Vi=sliderToV(+vol.value); Vf=null; onAnyChange(); });
    document.getElementById('markFim').addEventListener('click', ()=>{ if(Vi===null) Vi=sliderToV(+vol.value); Vf=sliderToV(+vol.value); onAnyChange(); });
    document.getElementById('reset').addEventListener('click', ()=>{ Vi=null; Vf=null; traj.style.display='none'; onAnyChange(); });

    // ---------- Inicialização ----------
    updateScene(+vol.value, prevVol); onAnyChange();
  </script>
</body>
</html>
